import 'dart:convert';
import 'package:shared_preferences/shared_preferences.dart';
import 'api_service.dart';
import '../config/api_config.dart';
import '../models/user_model.dart';

class BackendUserService {
  final ApiService _apiService = ApiService();
  static const String _cachedUsersKey = 'cached_users';
  static const String _cachedRolesKey = 'cached_roles';
  static const String _cachedProgramStudiesKey = 'cached_program_studies';

  // ============ USER MANAGEMENT ============
  
  // Get all users (now public endpoint - no auth needed)
  Future<List<UserModel>> getAllUsers() async {
    try {
      final response = await _apiService.get(ApiConfig.users, includeAuth: false);
      final List<dynamic> data = response is List ? response : (response['results'] ?? []);
      final users = data.map((json) => UserModel.fromJson(json)).toList();
      
      // Cache the data for offline use
      await _cacheUsers(users);
      print('üë• Fetched ${users.length} users from backend (cached)');
      return users;
    } catch (e) {
      print('‚ùå Error fetching users (backend offline): $e');
      // Return cached data if available
      final cachedUsers = await _getCachedUsers();
      if (cachedUsers.isNotEmpty) {
        print('üì¶ Returning ${cachedUsers.length} cached users');
      }
      return cachedUsers;
    }
  }
  
  Future<void> _cacheUsers(List<UserModel> users) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final jsonList = users.map((u) => u.toJson()).toList();
      await prefs.setString(_cachedUsersKey, jsonEncode(jsonList));
    } catch (e) {
      print('‚ö†Ô∏è Failed to cache users: $e');
    }
  }
  
  Future<List<UserModel>> _getCachedUsers() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final cached = prefs.getString(_cachedUsersKey);
      if (cached != null) {
        final List<dynamic> jsonList = jsonDecode(cached);
        return jsonList.map((json) => UserModel.fromJson(json)).toList();
      }
    } catch (e) {
      print('‚ö†Ô∏è Failed to load cached users: $e');
    }
    return [];
  }

  // Get user by ID
  Future<UserModel> getUserById(String id) async {
    try {
      final response = await _apiService.get('${ApiConfig.users}$id/');
      return UserModel.fromJson(response);
    } catch (e) {
      throw Exception('Failed to fetch user: $e');
    }
  }

  // Create new user
  Future<UserModel> createUser(dynamic user, {String? password}) async {
    try {
      Map<String, dynamic> userData;
      if (user is UserModel) {
        userData = user.toJson();
      } else if (user is Map<String, dynamic>) {
        userData = Map<String, dynamic>.from(user);
      } else {
        throw Exception('Invalid user data type');
      }
      
      // Add password if provided as separate parameter (fallback)
      if (password != null && password.isNotEmpty) {
        userData['password'] = password;
      }
      
      // If password is not in userData and not provided as parameter, it will be auto-generated by backend
      print('üîê Creating user: ${userData['id']}');
      if (userData.containsKey('password')) {
        print('   - Password: ${userData['password'].isNotEmpty ? "Custom (${userData['password'].length} chars)" : "Will be auto-generated"}');
      } else {
        print('   - Password: Will be auto-generated by backend');
      }
      
      final response = await _apiService.post(ApiConfig.users, userData);
      print('‚úÖ User created successfully');
      return UserModel.fromJson(response);
    } catch (e) {
      print('‚ùå Error creating user: $e');
      throw Exception('Failed to create user: $e');
    }
  }

  // Update user
  Future<UserModel> updateUser(String id, dynamic user, {String? password}) async {
    try {
      Map<String, dynamic> userData;
      if (user is UserModel) {
        userData = user.toJson();
      } else if (user is Map<String, dynamic>) {
        userData = Map<String, dynamic>.from(user);
      } else {
        throw Exception('Invalid user data type');
      }
      
      // Add password if provided as separate parameter (fallback)
      if (password != null && password.isNotEmpty) {
        userData['password'] = password;
      }
      
      print('üîê Updating user: $id');
      if (userData.containsKey('password') && userData['password'] != null && userData['password'].toString().isNotEmpty) {
        print('   - New password: Custom (${userData['password'].toString().length} chars)');
      } else {
        print('   - Password: Not changed (no password field sent)');
      }
      
      final response = await _apiService.put(
        '${ApiConfig.users}$id/',
        userData,
        includeAuth: false,
      );
      print('‚úÖ User updated successfully');
      return UserModel.fromJson(response);
    } catch (e) {
      print('‚ùå Error updating user: $e');
      throw Exception('Failed to update user: $e');
    }
  }

  // Partial update user
  Future<UserModel> patchUser(String id, Map<String, dynamic> updates) async {
    try {
      final response = await _apiService.patch(
        '${ApiConfig.users}$id/',
        updates,
      );
      return UserModel.fromJson(response);
    } catch (e) {
      throw Exception('Failed to update user: $e');
    }
  }

  // Delete user
  Future<void> deleteUser(String id) async {
    try {
      await _apiService.delete('${ApiConfig.users}$id/', includeAuth: false);
    } catch (e) {
      throw Exception('Failed to delete user: $e');
    }
  }

  // ============ ROLE MANAGEMENT ============
  
  // Get all roles (public endpoint - no auth needed for GET)
  Future<List<RoleModel>> getAllRoles() async {
    try {
      final response = await _apiService.get(ApiConfig.roles, includeAuth: false);
      final List<dynamic> data = response is List ? response : (response['results'] ?? []);
      final roles = data.map((json) => RoleModel.fromJson(json)).toList();
      
      // Cache the data for offline use
      await _cacheRoles(roles);
      print('üìã Fetched ${roles.length} roles from backend (cached)');
      return roles;
    } catch (e) {
      print('‚ùå Error fetching roles (backend offline): $e');
      // Return cached data if available
      final cachedRoles = await _getCachedRoles();
      if (cachedRoles.isNotEmpty) {
        print('üì¶ Returning ${cachedRoles.length} cached roles');
      }
      return cachedRoles;
    }
  }
  
  Future<void> _cacheRoles(List<RoleModel> roles) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final jsonList = roles.map((r) => r.toJson()).toList();
      await prefs.setString(_cachedRolesKey, jsonEncode(jsonList));
    } catch (e) {
      print('‚ö†Ô∏è Failed to cache roles: $e');
    }
  }
  
  Future<List<RoleModel>> _getCachedRoles() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final cached = prefs.getString(_cachedRolesKey);
      if (cached != null) {
        final List<dynamic> jsonList = jsonDecode(cached);
        return jsonList.map((json) => RoleModel.fromJson(json)).toList();
      }
    } catch (e) {
      print('‚ö†Ô∏è Failed to load cached roles: $e');
    }
    return [];
  }

  // Get role by ID
  Future<RoleModel> getRoleById(int id) async {
    try {
      final response = await _apiService.get('${ApiConfig.roles}$id/');
      return RoleModel.fromJson(response);
    } catch (e) {
      throw Exception('Failed to fetch role: $e');
    }
  }

  // Create role
  Future<RoleModel> createRole(RoleModel role) async {
    try {
      final response = await _apiService.post(ApiConfig.roles, role.toJson());
      return RoleModel.fromJson(response);
    } catch (e) {
      throw Exception('Failed to create role: $e');
    }
  }

  // Update role
  Future<RoleModel> updateRole(int id, RoleModel role) async {
    try {
      final response = await _apiService.put(
        '${ApiConfig.roles}$id/',
        role.toJson(),
      );
      return RoleModel.fromJson(response);
    } catch (e) {
      throw Exception('Failed to update role: $e');
    }
  }

  // Delete role
  Future<void> deleteRole(int id) async {
    try {
      await _apiService.delete('${ApiConfig.roles}$id/');
    } catch (e) {
      throw Exception('Failed to delete role: $e');
    }
  }

  // ============ FACULTY MANAGEMENT ============
  
  // Get all faculties
  Future<List<FacultyModel>> getAllFaculties() async {
    try {
      final response = await _apiService.get(ApiConfig.faculties);
      final List<dynamic> data = response is List ? response : (response['results'] ?? []);
      return data.map((json) => FacultyModel.fromJson(json)).toList();
    } catch (e) {
      throw Exception('Failed to fetch faculties: $e');
    }
  }

  // Get faculty by ID
  Future<FacultyModel> getFacultyById(int id) async {
    try {
      final response = await _apiService.get(ApiConfig.facultyDetail(id));
      return FacultyModel.fromJson(response);
    } catch (e) {
      throw Exception('Failed to fetch faculty: $e');
    }
  }

  // Create faculty
  Future<FacultyModel> createFaculty(FacultyModel faculty) async {
    try {
      final response = await _apiService.post(ApiConfig.faculties, faculty.toJson());
      return FacultyModel.fromJson(response);
    } catch (e) {
      throw Exception('Failed to create faculty: $e');
    }
  }

  // Update faculty
  Future<FacultyModel> updateFaculty(int id, FacultyModel faculty) async {
    try {
      final response = await _apiService.put(
        ApiConfig.facultyDetail(id),
        faculty.toJson(),
      );
      return FacultyModel.fromJson(response);
    } catch (e) {
      throw Exception('Failed to update faculty: $e');
    }
  }

  // Delete faculty
  Future<void> deleteFaculty(int id) async {
    try {
      await _apiService.delete(ApiConfig.facultyDetail(id));
    } catch (e) {
      throw Exception('Failed to delete faculty: $e');
    }
  }

  // ============ DEPARTMENT MANAGEMENT ============
  
  // Get all departments
  Future<List<DepartmentModel>> getAllDepartments({int? facultyId}) async {
    try {
      String endpoint = ApiConfig.departments;
      if (facultyId != null) {
        endpoint += '?faculty_id=$facultyId';
      }
      final response = await _apiService.get(endpoint);
      final List<dynamic> data = response is List ? response : (response['results'] ?? []);
      return data.map((json) => DepartmentModel.fromJson(json)).toList();
    } catch (e) {
      throw Exception('Failed to fetch departments: $e');
    }
  }

  // Get department by ID
  Future<DepartmentModel> getDepartmentById(int id) async {
    try {
      final response = await _apiService.get(ApiConfig.departmentDetail(id));
      return DepartmentModel.fromJson(response);
    } catch (e) {
      throw Exception('Failed to fetch department: $e');
    }
  }

  // Create department
  Future<DepartmentModel> createDepartment(DepartmentModel department) async {
    try {
      final response = await _apiService.post(
        ApiConfig.departments,
        department.toJson(),
      );
      return DepartmentModel.fromJson(response);
    } catch (e) {
      throw Exception('Failed to create department: $e');
    }
  }

  // Update department
  Future<DepartmentModel> updateDepartment(int id, DepartmentModel department) async {
    try {
      final response = await _apiService.put(
        ApiConfig.departmentDetail(id),
        department.toJson(),
      );
      return DepartmentModel.fromJson(response);
    } catch (e) {
      throw Exception('Failed to update department: $e');
    }
  }

  // Delete department
  Future<void> deleteDepartment(int id) async {
    try {
      await _apiService.delete(ApiConfig.departmentDetail(id));
    } catch (e) {
      throw Exception('Failed to delete department: $e');
    }
  }

  // ============ PROGRAM STUDY MANAGEMENT ============
  
  // Get all program studies (public endpoint - no auth needed for GET)
  Future<List<ProgramStudyModel>> getAllProgramStudies({int? facultyId}) async {
    try {
      String endpoint = ApiConfig.programStudies;
      if (facultyId != null) {
        endpoint += '?faculty_id=$facultyId';
      }
      final response = await _apiService.get(endpoint, includeAuth: false);
      final List<dynamic> data = response is List ? response : (response['results'] ?? []);
      final programStudies = data.map((json) => ProgramStudyModel.fromJson(json)).toList();
      
      // Cache the data for offline use
      await _cacheProgramStudies(programStudies);
      print('üìö Fetched ${programStudies.length} program studies from backend (cached)');
      return programStudies;
    } catch (e) {
      print('‚ùå Error fetching program studies (backend offline): $e');
      // Return cached data if available
      final cachedProgramStudies = await _getCachedProgramStudies();
      if (cachedProgramStudies.isNotEmpty) {
        print('üì¶ Returning ${cachedProgramStudies.length} cached program studies');
      }
      return cachedProgramStudies;
    }
  }
  
  Future<void> _cacheProgramStudies(List<ProgramStudyModel> programStudies) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final jsonList = programStudies.map((p) => p.toJson()).toList();
      await prefs.setString(_cachedProgramStudiesKey, jsonEncode(jsonList));
    } catch (e) {
      print('‚ö†Ô∏è Failed to cache program studies: $e');
    }
  }
  
  Future<List<ProgramStudyModel>> _getCachedProgramStudies() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final cached = prefs.getString(_cachedProgramStudiesKey);
      if (cached != null) {
        final List<dynamic> jsonList = jsonDecode(cached);
        return jsonList.map((json) => ProgramStudyModel.fromJson(json)).toList();
      }
    } catch (e) {
      print('‚ö†Ô∏è Failed to load cached program studies: $e');
    }
    return [];
  }

  // Get program study by ID
  Future<ProgramStudyModel> getProgramStudyById(int id) async {
    try {
      final response = await _apiService.get(ApiConfig.programStudyDetail(id));
      return ProgramStudyModel.fromJson(response);
    } catch (e) {
      throw Exception('Failed to fetch program study: $e');
    }
  }

  // Create program study
  Future<ProgramStudyModel> createProgramStudy(ProgramStudyModel programStudy) async {
    try {
      final response = await _apiService.post(
        ApiConfig.programStudies,
        programStudy.toJson(),
      );
      return ProgramStudyModel.fromJson(response);
    } catch (e) {
      throw Exception('Failed to create program study: $e');
    }
  }

  // Update program study
  Future<ProgramStudyModel> updateProgramStudy(int id, ProgramStudyModel programStudy) async {
    try {
      final response = await _apiService.put(
        ApiConfig.programStudyDetail(id),
        programStudy.toJson(),
      );
      return ProgramStudyModel.fromJson(response);
    } catch (e) {
      throw Exception('Failed to update program study: $e');
    }
  }

  // Delete program study
  Future<void> deleteProgramStudy(int id) async {
    try {
      await _apiService.delete(ApiConfig.programStudyDetail(id));
    } catch (e) {
      throw Exception('Failed to delete program study: $e');
    }
  }

  // ============ PERIOD MANAGEMENT ============
  
  // Get all periods
  Future<List<dynamic>> getAllPeriods() async {
    try {
      final response = await _apiService.get(ApiConfig.periodes);
      return response is List ? response : (response['results'] ?? []);
    } catch (e) {
      throw Exception('Failed to fetch periods: $e');
    }
  }

  // Get period by ID
  Future<Map<String, dynamic>> getPeriodById(int id) async {
    try {
      return await _apiService.get(ApiConfig.periodeDetail(id));
    } catch (e) {
      throw Exception('Failed to fetch period: $e');
    }
  }
}
